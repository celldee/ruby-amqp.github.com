<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head>
  <title>
    Ruby amqp gem:
    Error handling and recovery
  </title>
  <link href='/assets/stylesheets/sass/styles.css' media='screen' rel='stylesheet' type='text/css' />
</head>
<script src='/assets/javascripts/jquery-1.7.min.js' type='text/javascript'></script>
<script src='/assets/javascripts/codemirror.js'></script>
<script src='/assets/javascripts/toc.js'></script>
<script src='/assets/javascripts/code_highlight.js'></script>
<link href='/assets/stylesheets/codemirror.css' rel='stylesheet' />
<script src='/assets/javascripts/mode/ruby.js'></script>
<link href='/assets/stylesheets/theme/default.css' rel='stylesheet' />
<script type='text/javascript'>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27153041-1']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script><body><div class='topbar'>
  <div class='topbar-inner'>
    <div class='container'>
      <ul class='nav'>
        <li>
          <a href='/'>
            Home
          </a>
        </li>
        <li>
          <a href='/articles/getting_started/'>
            Getting Started
          </a>
        </li>
        <li>
          <a href='/articles/amqp_9_1_model_explained/'>
            AMQP 0.9.1 Model
          </a>
        </li>
        <li>
          <a href='/articles/connecting_to_broker/'>
            Connecting
          </a>
        </li>
        <li>
          <a href='/articles/working_with_queues/'>
            Queues
          </a>
        </li>
        <li>
          <a href='/articles/working_with_exchanges/'>
            Exchanges
          </a>
        </li>
        <li>
          <a href='/articles/patterns_and_use_cases/'>
            Patterns & Use Cases
          </a>
        </li>
        <li>
          <a href='/articles/error_handling/'>
            Error Handling
          </a>
        </li>
      </ul>
    </div>
  </div>
</div><section class='content'><article><div class='toc'></div>
<h1>Error handling and recovery</h1>
<h2>About this guide</h2>
<p>Development of a robust application, be it message publisher or message consumer, involves dealing withmultiple kinds of failures: protocol exceptions, network failures, broker failures and so on.Correct error handling and recovery is not easy. This guide explains how amqp gem helps you in dealing withissues like</p>
<ul>
	<li>Initial broker connection failures</li>
	<li>Network connection interruption</li>
	<li><span class="caps">AMQP</span> connection-level exceptions</li>
	<li><span class="caps">AMQP</span> channel-level exceptions</li>
	<li>Broker failure</li>
	<li><span class="caps">TLS</span> (<span class="caps">SSL</span>) related issues</li>
</ul>
<p>as well as</p>
<ul>
	<li>How to recover after a network failure</li>
	<li>What is automatic recovery mode, when you should and should not use it</li>
</ul>
<p>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a> (including images &amp; stylesheets). The source is available <a href="https://github.com/ruby-amqp/amqp/tree/master/docs">on Github</a>.</p>
<h2>Covered versions</h2>
<p>This guide covers <a href="http://github.com/ruby-amqp/amqp">Ruby amqp gem</a> v0.8.0.RC14 and later.</p>
<h2>Code examples</h2>
<p>There are several {https://github.com/ruby-amqp/amqp/tree/master/examples/error_handling examples}  in the git repository dedicated to the topic of error handling and recovery. Feelfree to contribute new examples.</p>
<h3>Initial broker connection failures</h3>
<p>When applications connect to the broker, they need to handle connection failures. Networks are not 100% reliable, even with modern system configuration toolslike Chef or Puppet misconfigurations happen and broker might be down, too. Error detection should happen as early as possible. There are two ways of detectingTCP connection failure, the first one is to catch an exception:</p>
<pre>begin
  AMQP.start(connection_settings) do |connection, open_ok|
    raise "This should not be reachable"
  end
rescue AMQP::TCPConnectionFailed =&gt; e
  puts "Caught AMQP::TCPConnectionFailed =&gt; TCP connection failed, as expected."
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"


puts "=&gt; TCP connection failure handling with a rescue statement"
puts

connection_settings = {
  :port     =&gt; 9689,
  :vhost    =&gt; "/amq_client_testbed",
  :user     =&gt; "amq_client_gem",
  :password =&gt; "amq_client_gem_password",
  :timeout        =&gt; 0.3
}

begin
  AMQP.start(connection_settings) do |connection, open_ok|
    raise "This should not be reachable"
  end
rescue AMQP::TCPConnectionFailed =&gt; e
  puts "Caught AMQP::TCPConnectionFailed =&gt; TCP connection failed, as expected."
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1016238">gist</a>)</span></p>
<p><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP#connect-class_method"><span class="caps">AMQP</span>.connect</a> (and <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP#start-class_method"><span class="caps">AMQP</span>.start</a>) will raise <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/TCPConnectionFailed"><span class="caps">AMQP</span>::TCPConnectionFailed</a> if connection fails. Code that catches it can write to logabout the issue or use retry to execute begin block one more time. Because initial connection failures are due to misconfiguration or network outage, reconnectionto the same endpoint (hostname, port, vhost combination) will result in the same issue over and over. <span class="caps">TBD</span>: failover, connection to the cluster.</p>
<p>Alternative way of handling connection failure is with an errback (a callback for specific kind of error):</p>
<pre>handler             = Proc.new { |settings| puts "Failed to connect, as expected"; EventMachine.stop }
connection_settings = {
  :port     =&gt; 9689,
  :vhost    =&gt; "/amq_client_testbed",
  :user     =&gt; "amq_client_gem",
  :password =&gt; "amq_client_gem_password",
  :timeout        =&gt; 0.3,
  :on_tcp_connection_failure =&gt; handler
}</pre>
<p>Full example:</p>
<pre>require "rubygems"
require "amqp"

puts "=&gt; TCP connection failure handling with a callback"
puts

handler             = Proc.new { |settings| puts "Failed to connect, as expected"; EM.stop }
connection_settings = {
  :port     =&gt; 9689,
  :vhost    =&gt; "/amq_client_testbed",
  :user     =&gt; "amq_client_gem",
  :password =&gt; "amq_client_gem_password",
  :timeout        =&gt; 0.3,
  :on_tcp_connection_failure =&gt; handler
}


AMQP.start(connection_settings) do |connection, open_ok|
  raise "This should not be reachable"
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1016235">gist</a>)</span></p>
<p>:on_tcp_connection_failure option accepts any object that responds to #call.</p>
<p>If you connect to the broker from a code in a class (as opposed to top-level scope in a script), Object#method can be used to pass object method as a handlerinstead of a Proc.</p>
<p><span class="caps">TBD</span>: provide an example</p>
<h3>Authentication failures</h3>
<p>Another reason why connection may fail is authentication failure. Handling authentication failure is very similar to handling initial TCPconnection failure:</p>
<pre>require "rubygems"
require "amqp"

puts "=&gt; Authentication failure handling with a callback"
puts

handler             = Proc.new { |settings| puts "Failed to connect, as expected"; EM.stop }
connection_settings = {
  :port     =&gt; 5672,
  :vhost    =&gt; "/amq_client_testbed",
  :user     =&gt; "amq_client_gem",
  :password =&gt; "amq_client_gem_password_that_is_incorrect #{Time.now.to_i}",
  :timeout        =&gt; 0.3,
  :on_tcp_connection_failure =&gt; handler,
  :on_possible_authentication_failure =&gt; Proc.new { |settings|
                                            puts "Authentication failed, as expected, settings are: #{settings.inspect}"

                                            EM.stop
                                          }
}

AMQP.start(connection_settings) do |connection, open_ok|
  raise "This should not be reachable"
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1016233">gist</a>)</span></p>
<h4>Default handler</h4>
<p>default handler raises <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/PossibleAuthenticationFailureError"><span class="caps">AMQP</span>::PossibleAuthenticationFailureError</a>:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

puts "=&gt; Authentication failure handling with a rescue block"
puts

handler             = Proc.new { |settings| puts "Failed to connect, as expected"; EM.stop }
connection_settings = {
  :port     =&gt; 5672,
  :vhost    =&gt; "/amq_client_testbed",
  :user     =&gt; "amq_client_gem",
  :password =&gt; "amq_client_gem_password_that_is_incorrect #{Time.now.to_i}",
  :timeout        =&gt; 0.3,
  :on_tcp_connection_failure =&gt; handler
}


begin
  AMQP.start(connection_settings) do |connection, open_ok|
    raise "This should not be reachable"
  end
rescue AMQP::PossibleAuthenticationFailureError =&gt; afe
  puts "Authentication failed, as expected, caught #{afe.inspect}"
  EventMachine.stop if EventMachine.reactor_running?
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1016234">gist</a>)</span></p>
<p>In case you wonder why callback name has &#8220;possible&#8221; in it: <a href="http://bit.ly/amqp091spec"><span class="caps">AMQP</span> 0.9.1 spec</a> requires broker implementations tosimply close <span class="caps">TCP</span> connection without sending any more data when an exception (such as authentication failure) occurs before <span class="caps">AMQP</span> connectionis open. In practice, however, when broker closes <span class="caps">TCP</span> connection between successful <span class="caps">TCP</span> connection and before <span class="caps">AMQP</span> connection is open,it means that authentication has failed.</p>
<h2>Handling network connection interruptions</h2>
<p>Network connectivity issues are sad fact of life in modern software systems. Event small products and projects these days consist of multipleapplications, often running on more than one machine. Ruby amqp gem detects <span class="caps">TCP</span> connection failures and lets you handle them bydefining a callback using <span class="highlight"><span class="caps">AMQP</span>::Session#on_tcp_connection_loss</span>. That callback will be run when <span class="caps">TCP</span> connection fails, and will be passedtwo parameters: connection object and settings of the last successful connection.</p>
<pre>connection.on_tcp_connection_loss do |connection, settings|
  # reconnect in 10 seconds, without enforcement
  connection.reconnect(false, 10)
end</pre>
<p>Sometimes it is necessary for other entities in an application to react to network failures. amqp gem 0.8.0 and later provides a number eventhandlers to make this task easier for developers. This set of features is know as the &#8220;shutdown protocol&#8221; (the word &#8220;protocol&#8221; here means&quot;API interface&quot; or &#8220;behavior&#8221;, not network protocol).</p>
<p><span class="highlight"><span class="caps">AMQP</span>::Session</span>, <span class="highlight"><span class="caps">AMQP</span>::Channel</span>, <span class="highlight"><span class="caps">AMQP</span>::Exchange</span>, <span class="highlight"><span class="caps">AMQP</span>::Queue</span> and <span class="highlight"><span class="caps">AMQP</span>::Consumer</span> all implement shutdown protocol and thus errorhandling <span class="caps">API</span> is consistent for all classes, with <span class="highlight"><span class="caps">AMQP</span>::Session</span> and <span class="highlight"><span class="caps">AMQP</span>::Channel</span> having a few methods other entities do not have.</p>
<p>The Shutdown protocol revolves around two events:</p>
<ul>
	<li>Network connection fails</li>
	<li>Broker closes <span class="caps">AMQP</span> connection (or channel)</li>
</ul>
<p>In this section, we concentrate only on the former. When network connection fails, the underlying networking library detects it andruns a piece of code on <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Session"><span class="caps">AMQP</span>::Session</a> to handle it. That, in turn, propagates this event to channels, channels propagate it toexchanges and queues, queues propagate it to their consumers (if any). Each of these entities in the object graph can reactto network interruption by executing application-defined callbacks.</p>
<h3>Shutdown Protocol methods on <span class="caps">AMQP</span>::Session</h3>
<ul>
	<li><span class="highlight"><span class="caps">AMQP</span>::Session#on_tcp_connection_loss</span></li>
	<li><span class="highlight"><span class="caps">AMQP</span>::Session#on_connection_interruption</span></li>
</ul>
<p>The difference between these methods is that <span class="highlight"><span class="caps">AMQP</span>::Session#on_tcp_connection_loss</span> is used to define a callback that willbe executed <strong>once</strong> when <span class="caps">TCP</span> connection fails. It is possible that reconnection attempts will not succeed immediately, sothere will be subsequent failures. To react to those, <span class="highlight"><span class="caps">AMQP</span>::Session#on_connection_interruption</span> method is used.</p>
<p>First argument that both of these methods yield to the handler your application defines is the connection itself. This isdone to make sure you can register Ruby objects as handlers, and they do not have to keep any state around (for example,connection instances):</p>
<pre>connection.on_connection_interruption do |conn|
  puts "Connection detected connection interruption"
end

# or

class ConnectionInterruptionHandler

  #
  # API
  #

  def handle(connection)
    # handling logic
  end

end

handler = ConnectionInterruptionHandler.new
connection.on_connection_interruption(&amp;handler.method(:handle))</pre>
<p>Note that <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Session#on_connection_interruption-instance_method"><span class="caps">AMQP</span>::Session#on_connection_interruption</a> callback is called <strong>before</strong> this event is propagated to channels, queues and so on.</p>
<p>Different applications handle connection failures differently. It is very common to use <span class="highlight"><span class="caps">AMQP</span>::Session#reconnect</span> methodto schedule a reconnection to the same host, or use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Session#reconnect_to-instance_method"><span class="caps">AMQP</span>::Session#reconnect_to</a> to connect to a different one.<br />
For some applications it is OK to simply exit and wait to be restarted at a later point in time, for example, by a processmonitoring system like Nagios or Monit.</p>
<h3>Shutdown Protocol methods on <span class="caps">AMQP</span>::Channel</h3>
<p><span class="highlight"><span class="caps">AMQP</span>::Channel</span> provides only one method: <span class="highlight"><span class="caps">AMQP</span>::Channel#on_connection_interruption</span>, that registers a callback similar tothe one seen in the previous section:</p>
<pre>channel.on_connection_interruption do |ch|
  puts "Channel #{ch.id} detected connection interruption"
end</pre>
<p>Note that <span class="highlight"><span class="caps">AMQP</span>::Channel#on_connection_interruption</span> callback is called <strong>after</strong> this event is propagated to exchanges, queues and so on.Right after that channel state is reset, except for error handling/recovery-related callbacks.</p>
<p><span class="note">Many applications do not need per-channel network failure handling.<br />
</span></p>
<h3>Shutdown Protocol methods on <span class="caps">AMQP</span>::Exchange</h3>
<p><span class="highlight"><span class="caps">AMQP</span>::Exchange</span> provides only one method: <span class="highlight"><span class="caps">AMQP</span>::Exchange#on_connection_interruption</span>, that registers a callback similar tothe one seen in the previous section:</p>
<pre>exchange.on_connection_interruption do |ex|
  puts "Exchange #{ex.name} detected connection interruption"
end</pre>
<p><span class="note">Many applications do not need per-exchange network failure handling.</span></p>
<h3>Shutdown Protocol methods on <span class="caps">AMQP</span>::Queue</h3>
<p><span class="highlight"><span class="caps">AMQP</span>::Queue</span> provides only one method: <span class="highlight"><span class="caps">AMQP</span>::Queue#on_connection_interruption</span>, that registers a callback similar tothe one seen in the previous section:</p>
<pre>queue.on_connection_interruption do |q|
  puts "Queue #{q.name} detected connection interruption"
end</pre>
<p>Note that <span class="caps">AMQP</span>::Queue#on_connection_interruption callback is called <strong>after</strong> this event is propagated to consumers.</p>
<p><span class="note">Many applications do not need per-queue network failure handling.</span></p>
<h3>Shutdown Protocol methods on <span class="caps">AMQP</span>::Consumer</h3>
<p><span class="highlight"><span class="caps">AMQP</span>::Consumer</span> provides only one method: <span class="highlight"><span class="caps">AMQP</span>::Consumer#on_connection_interruption</span>, that registers a callback similar tothe one seen in the previous section:</p>
<pre>consumer.on_connection_interruption do |c|
  puts "Consumer with consumer tag #{c.consumer_tag} detected connection interruption"
end</pre>
<p><span class="note">Many applications do not need per-consumer network failure handling.</span></p>
<h2>Recovering from network connection failures</h2>
<p>Detecting network connections is nearly useless if <span class="caps">AMQP</span>-based application cannot recover from them. Recovery is the hard partin &#8220;error handling and recovery&#8221;. Fortunately, recovery process for many applications follows one simple scheme that amqpgem can perform automatically for you.</p>
<p><span class="note">Recovery process, both manual and automatic, always begins with re-opening <span class="caps">AMQP</span> connection and then all the channels on that connection.</span></p>
<h3>Manual recovery</h3>
<p>Similarly to the Shutdown Protocol, amqp gem entities implement Recovery Protocol. Recovery Protocol consists of 3 methodsconnections, channels, queues, consumers and exchanges implement:</p>
<ul>
	<li><span class="highlight"><span class="caps">AMQP</span>::Session#before_recovery</span></li>
	<li><span class="highlight"><span class="caps">AMQP</span>::Session#auto_recover</span></li>
	<li><span class="highlight"><span class="caps">AMQP</span>::Session#after_recovery</span></li>
</ul>
<p><span class="caps">AMQP</span>::Session#before_recovery lets application developers register a callback that will be executed <strong>after <span class="caps">TCP</span> connection isre-established but before <span class="caps">AMQP</span> connection is reopened</strong>. {AMQP::Session#after_recovery} is similar except that the callback is run*after <span class="caps">AMQP</span> connection is reopened*.</p>
<p><span class="highlight"><span class="caps">AMQP</span>::Channel</span>, <span class="highlight"><span class="caps">AMQP</span>::Queue</span>, <span class="highlight"><span class="caps">AMQP</span>::Consumer</span> and <span class="highlight"><span class="caps">AMQP</span>::Exchange</span> methods behavior is identical.</p>
<p>Recovery process for <span class="caps">AMQP</span> applications usually involves the following steps:</p>
<ol>
	<li>Re-open <span class="caps">AMQP</span> connection.</li>
	<li>Once connection is open again, re-open all <span class="caps">AMQP</span> channels on that connection.</li>
	<li>For each channel, re-declare all exchanges</li>
	<li>For each channel, re-declare all queues</li>
	<li>Once queue is declared, for each queue, re-register all bindings # Once queue is declared, for each queue, re-register all consumers</li>
</ol>
<h3>Automatic recovery</h3>
<p>Many applications use the same recovery strategy, that consists of the following steps:</p>
<ul>
	<li>Re-open channels</li>
	<li>For each channel, re-declare exchanges (except for predefined ones)</li>
	<li>For each channel, re-declare queues</li>
	<li>For each queue, recover all bindings</li>
	<li>For each queue, recover all consumers</li>
</ul>
<p>amqp gem provides a feature known as &#8220;automatic recovery&#8221; that is <strong>opt-in</strong> (not opt-out, not used by default) and lets applicationdevelopers get aforementioned recovery strategy by setting one additional attribute on <span class="caps">AMQP</span>::Channel instance:</p>
<pre>ch = AMQP::Channel.new(connection)
ch.auto_recovery = true</pre>
<p>A more verbose way to do the same thing:<br />
<pre>ch = <span class="caps">AMQP</span>::Channel.new(connection, <span class="caps">AMQP</span>::Channel.next_channel_id, :auto_recovery =&gt; true)</pre></p>
<p>Note that if you do not want to pass any options, 2nd argument can be left out as well,then it will default to <span class="highlight"><span class="caps">AMQP</span>::Channel.next_channel_id</span>.</p>
<p>To find out whether channel uses automatic recovery mode, use <span class="highlight"><span class="caps">AMQP</span>::Channel#auto_recovering?</span>.</p>
<p>Auto recovery mode can be turned on and off any number of times during channel life cycle, although very small percentage ofapplications really does this. Typically you decide what channels should be using automatic recovery at application designstage.</p>
<p>Full example (run it, then shut down <span class="caps">AMQP</span> broker running on localhost, then bring it back up and use management tools such as `rabbitmqctl`to see that queues &amp; bindings &amp; consumer have all recovered):</p>
<pre># encoding: utf-8
require "rubygems"
require "amqp" # requires version &gt;= 0.8.0.RC14

puts "=&gt; Example of automatic AMQP channel and queues recovery"

AMQP.start(:host =&gt; "localhost") do |connection, open_ok|
  connection.on_error do |ch, connection_close|
    raise connection_close.reply_text
  end

  ch1 = AMQP::Channel.new(connection)
  ch1.auto_recovery = true
  ch1.on_error do |ch, channel_close|
    raise channel_close.reply_text
  end

  if ch1.auto_recovering?
    puts "Channel #{ch1.id} IS auto-recovering"
  end

  connection.on_tcp_connection_loss do |conn, settings|
    puts "[network failure] Trying to reconnect..."
    conn.reconnect(false, 2)
  end


  ch1.queue("amqpgem.examples.queue1", :auto_delete =&gt; true).bind("amq.fanout")
  ch1.queue("amqpgem.examples.queue2", :auto_delete =&gt; true).bind("amq.fanout")
  ch1.queue("amqpgem.examples.queue3", :auto_delete =&gt; true).bind("amq.fanout").subscribe do |metadata, payload|
  end


  show_stopper = Proc.new {
    connection.disconnect { puts "Disconnected. Exiting..."; EventMachine.stop }
  }

  Signal.trap "TERM", show_stopper
  Signal.trap "INT",  show_stopper
  EM.add_timer(30, show_stopper)


  puts "Connected, authenticated. To really exercise this example, shut AMQP broker down for a few seconds. If you don't it will exit gracefully in 30 seconds."
end

</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1048076">gist</a>)</span></p>
<p>Server-named queues, when recovered automatically, will get <strong>new server-generated names</strong> to guarantee there are no name collisions.</p>
<p><span note="class">When in doubt, try using automatic recovery first. If it is not sufficient for you application, switch to manualrecovery using events and callbacks introduced in the &#8220;Manual recovery&#8221; section.</span></p>
<h2>Detecting broker failures</h2>
<p><span class="caps">AMQP</span> applications see broker failure as <span class="caps">TCP</span> connection loss. There is no reliable way to know whether there is a network splitor network peer is down.</p>
<h2><span class="caps">AMQP</span> connection-level exceptions</h2>
<h3>Handling connection-level exceptions</h3>
<p>Connection-level exceptions are rare and may indicate a serious issue with client library or in-flight data corruption. They mandatethat connection cannot be used any more and must be closed. In any case, your application should be prepared to handle this kind of errors.To define a handler, use <span class="highlight"><span class="caps">AMQP</span>::Session#on_error</span> method that takes a callback and yields two arguments to it when connection-level exception happens:</p>
<pre>connection.on_error do |conn, connection_close|
  puts "Handling a connection-level exception."
  puts
  puts "AMQP class id : #{connection_close.class_id}"
  puts "AMQP method id: #{connection_close.method_id}"
  puts "Status code   : #{connection_close.reply_code}"
  puts "Error message : #{connection_close.reply_text}"
end</pre>
<p>Status codes are similar to those of <span class="caps">HTTP</span>. For the full list of error codes and their meaning, consult <a href="http://www.rabbitmq.com/amqp-0-9-1-reference.html#constants"><span class="caps">AMQP</span> 0.9.1 constants reference</a>.</p>
<p><span class="note">Only one connection-level exception handler can be defined per connection instance (the one added last replaces previously added ones).</span></p>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "bundler"
Bundler.setup

$:.unshift(File.expand_path("../../../lib", __FILE__))

require 'amqp'

EventMachine.run do
  AMQP.connect(:host =&gt; '127.0.0.1', :port =&gt; 5672) do |connection|
    puts "Connected to AMQP broker. Running #{AMQP::VERSION} version of the gem..."


    connection.on_error do |conn, connection_close|
      puts &lt;&lt;-ERR
      Handling a connection-level exception.

      AMQP class id : #{connection_close.class_id},
      AMQP method id: #{connection_close.method_id},
      Status code   : #{connection_close.reply_code}
      Error message : #{connection_close.reply_text}
      ERR

      EventMachine.stop
    end

    # send_frame is NOT part of the public API, but it is public for entities like AMQ::Client::Channel
    # and we use it here to trigger a connection-level exception. MK.
    connection.send_frame(AMQ::Protocol::Connection::TuneOk.encode(1000, 1024 * 128 * 1024, 10))
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1015966">gist</a>)</span></p>
<h2>Handling graceful broker shutdown</h2>
<p>When <span class="caps">AMQP</span> broker is shut down, it properly closes connection first. To do so, it uses <strong>connection.close</strong> <span class="caps">AMQP</span> method. <span class="caps">AMQP</span> clients thenneed to check if the reply code is equal to 320 (CONNECTION_FORCED) to distinguish graceful shutdown. With RabbitMQ, when brokeris stopped using</p>
<p><code>rabbitmqctl stop</code></p>
<p>reply_text will be set to</p>
<p><code>CONNECTION_FORCED - broker forced connection closure with reason 'shutdown'</code></p>
<p>Each application choose how to handle graceful broker shutdowns individually, so <strong>amqp gem&#8217;s automatic reconnection does not cover graceful broker shutdowns</strong>.Applications that want to reconnect when broker is stopped can use <span class="highlight"><span class="caps">AMQP</span>::Session#periodically_reconnect</span> like so:</p>
<pre>connection.on_error do |conn, connection_close|
  puts "[connection.close] Reply code = #{connection_close.reply_code}, reply text = #{connection_close.reply_text}"
  if connection_close.reply_code == 320
    puts "[connection.close] Setting up a periodic reconnection timer..."
    # every 30 seconds
    conn.periodically_reconnect(30)
  end
end</pre>
<p>Once <span class="caps">AMQP</span> connection is re-opened, channels in automatic recovery mode will recover just like they do after network outages.</p>
<h2>Integrating channel-level exceptions handling with object-oriented Ruby code</h2>
<p>Error handling can be easily integrated into object-oriented Ruby code (in fact, this is highly encouraged).A common technique is to combine {http://rubydoc.info/stdlib/core/1.8.7/Object:method Object#method} and {http://rubydoc.info/stdlib/core/1.8.7/Method:to_proc Method#to_proc} and use object methods as error handlers:</p>
<pre>class ConnectionManager

  #
  # API
  #

  def connect(*args, &amp;block)
    @connection = AMQP.connect(*args, &amp;block)

    # combines Object#method and Method#to_proc to use object
    # method as a callback
    @connection.on_error(&amp;method(:on_error))
  end # connect(*args, &amp;block)


  def on_error(connection, connection_close)
    puts "Handling a connection-level exception."
    puts
    puts "AMQP class id : #{connection_close.class_id}"
    puts "AMQP method id: #{connection_close.method_id}"
    puts "Status code   : #{connection_close.reply_code}"
    puts "Error message : #{connection_close.reply_text}"
  end # on_error(connection, connection_close)
end</pre>
<p>Full example that uses objects:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "bundler"
Bundler.setup

$:.unshift(File.expand_path("../../../lib", __FILE__))

require 'amqp'


class ConnectionManager

  #
  # API
  #

  def connect(*args, &amp;block)
    @connection = AMQP.connect(*args, &amp;block)

    # combines Object#method and Method#to_proc to use object
    # method as a callback
    @connection.on_error(&amp;method(:on_error))
  end # connect(*args, &amp;block)


  def on_error(connection, connection_close)
    puts "Handling a connection-level exception."
    puts
    puts "AMQP class id : #{connection_close.class_id}"
    puts "AMQP method id: #{connection_close.method_id}"
    puts "Status code   : #{connection_close.reply_code}"
    puts "Error message : #{connection_close.reply_text}"
  end # on_error(connection, connection_close)
end

EventMachine.run do
  manager = ConnectionManager.new
  manager.connect(:host =&gt; '127.0.0.1', :port =&gt; 5672) do |connection|
    puts "Connected to AMQP broker. Running #{AMQP::VERSION} version of the gem..."

    # send_frame is NOT part of the public API, but it is public for entities like AMQ::Client::Channel
    # and we use it here to trigger a connection-level exception. MK.
    connection.send_frame(AMQ::Protocol::Connection::TuneOk.encode(1000, 1024 * 128 * 1024, 10))
  end

  # shut down after 2 seconds
  EventMachine.add_timer(2) { EventMachine.stop }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1016049">gist</a>)</span></p>
<p><span class="caps">TBD</span></p>
<h2><span class="caps">AMQP</span> channel-level exceptions</h2>
<h3>Hanling channel-level exceptions</h3>
<p>Channel-level exceptions are more common than connection-level ones. They are handled in a similar manner, by defining a callbackwith <span class="highlight"><span class="caps">AMQP</span>::Channel#on_error</span> method that takes a callback and yields two arguments to it when channel-level exception happens:</p>
<pre>channel.on_error do |ch, channel_close|
  puts "Handling a channel-level exception."
  puts
  puts "AMQP class id : #{channel_close.class_id}"
  puts "AMQP method id: #{channel_close.method_id}"
  puts "Status code   : #{channel_close.reply_code}"
  puts "Error message : #{channel_close.reply_text}"
end</pre>
<p>Status codes are similar to those of <span class="caps">HTTP</span>. For the full list of error codes and their meaning, consult {http://www.rabbitmq.com/amqp-0-9-1-reference.html#constants <span class="caps">AMQP</span> 0.9.1 constants reference}.</p>
<p><span class="note">Only one channel-level exception handler can be defined per channel instance (the one added last replaces previously added ones).</span></p>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "bundler"
Bundler.setup

$:.unshift(File.expand_path("../../../lib", __FILE__))

require 'amqp'


puts "=&gt; Queue redeclaration with different attributes results in a channel exception that is handled"
puts
AMQP.start("amqp://guest:guest@dev.rabbitmq.com:5672") do |connection, open_ok|
  AMQP::Channel.new do |channel, open_ok|
    puts "Channel ##{channel.id} is now open!"

    channel.on_error do |ch, channel_close|
      puts &lt;&lt;-ERR
      Handling a channel-level exception.

      AMQP class id : #{channel_close.class_id},
      AMQP method id: #{channel_close.method_id},
      Status code   : #{channel_close.reply_code}
      Error message : #{channel_close.reply_text}
      ERR
    end

    EventMachine.add_timer(0.4) do
      # these two definitions result in a race condition. For sake of this example,
      # however, it does not matter. Whatever definition succeeds first, 2nd one will
      # cause a channel-level exception (because attributes are not identical)
      AMQP::Queue.new(channel, "amqpgem.examples.channel_exception", :auto_delete =&gt; true, :durable =&gt; false) do |queue|
        puts "#{queue.name} is ready to go"
      end

      AMQP::Queue.new(channel, "amqpgem.examples.channel_exception", :auto_delete =&gt; true, :durable =&gt; true) do |queue|
        puts "#{queue.name} is ready to go"
      end
    end
  end


  show_stopper = Proc.new do
    $stdout.puts "Stopping..."
    connection.close { EventMachine.stop }
  end

  Signal.trap "INT", show_stopper
  EM.add_timer(2, show_stopper)
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1016042">gist</a>)</span></p>
<h3>Integrating channel-level exceptions handling with object-oriented Ruby code</h3>
<p>Error handling can be easily integrated into object-oriented Ruby code (in fact, this is highly encouraged).A common technique is to combine <a href="http://rubydoc.info/stdlib/core/1.8.7/Object:method">Object#method</a> and <a href="http://rubydoc.info/stdlib/core/1.8.7/Method:to_proc">Method#to_proc</a> and use object methods as error handlers. For example of this, see section on connection-level exceptions above.</p>
<p><span class="note">Because channel-level exceptions may be raised because of multiple unrelated reasons and often indicate misconfigurations, how they are handled isvery specific to particular applications. A common strategy is to log an error and then open and use another channel.</span></p>
<h3>Common channel-level exceptions and what they mean</h3>
<p>A few channel-level exceptions are common and deserve more attention.</p>
<h4>406 Precondition Failed</h4>
<dl>
  <dt>Description</dt>
  <dd>The client requested a method that was not allowed because some precondition failed.</dd>
  <dt>What might cause it</dt>
<dd>
<ul>
      <li><span class="caps">AMQP</span> entity (a queue or exchange) was re-declared with attributes different from original declaration. Maybe two applications or pieces of code declare the same entity with different attributes. Note that different <span class="caps">AMQP</span> client libraries historically use slightly different defaults for entities and this may cause attribute mismatches.</li>
      <li><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#tx_commit-instance_method"><span class="caps">AMQP</span>::Channel#tx_commit</a> or <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#tx_rollback-instance_method"><span class="caps">AMQP</span>::Channel#tx_rollback</a> might be run on a channel that wasn&#8217;t previously made transactional with <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#tx_select-instance_method"><span class="caps">AMQP</span>::Channel#tx_select</a></li>
</ul>
</dd>
  <dt>Example RabbitMQ error message</dt>
<dd>
<ul>
      <li>PRECONDITION_FAILED &#8211; parameters for queue &#8216;amqpgem.examples.channel_exception&#8217; in vhost &#8216;/&#8217; not equivalent</li>
      <li>PRECONDITION_FAILED &#8211; channel is not transactional</li>
</ul>
</dd>
</dl>
<h4>405 Resource Locked</h4>
<dl>
  <dt>Description</dt>
  <dd>The client attempted to work with a server entity to which it has no access because another client is working with it.</dd>
  <dt>What might cause it</dt>
<dd>
<ul>
      <li>Multiple applications (or different pieces of code/threads/processes/routines within a single application) might try to declare queues with the same name as exclusive.</li>
      <li>Multiple consumer across multiple or single app might be registered as exclusive for the same queue.</li>
</ul>
</dd>
  <dt>Example RabbitMQ error message</dt>
  <dd>RESOURCE_LOCKED &#8211; cannot obtain exclusive access to locked queue &#8216;amqpgem.examples.queue&#8217; in vhost &#8216;/&#8217;</dd>
</dl>
<h4>403 Access Refused</h4>
<dl>
  <dt>Description</dt>
  <dd>The client attempted to work with a server entity to which it has no access due to security settings.</dd>
  <dt>What might cause it</dt>
  <dd>Application tries to access a queue or exchange it has no permissions for (or right kind of permissions, for example, write permissions)</dd>
  <dt>Example RabbitMQ error message</dt>
  <dd>ACCESS_REFUSED &#8211; access to queue &#8216;amqpgem.examples.channel_exception&#8217; in vhost &#8216;amqp_gem_testbed&#8217; refused for user &#8216;amqp_gem_reader&#8217;</dd>
</dl>
<h2><span class="caps">TLS</span> (<span class="caps">SSL</span>) related issues<br />
<span class="caps">TBD</span></h2>
<h2>Conclusion</h2>
<p>Distributed applications introduce a whole new class of failres developers need to be aware of. Many of them come fromunreliability of the network. The famous <a href="http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing">Fallacies of Distributed Computing</a> listcommon assumptions software engineers must not make:</p>
<ul>
	<li>The network is reliable.</li>
	<li>Latency is zero.</li>
	<li>Bandwidth is infinite.</li>
	<li>The network is secure.</li>
	<li>Topology doesn&#8217;t change.</li>
	<li>There is one administrator.</li>
	<li>Transport cost is zero.</li>
	<li>The network is homogeneous.</li>
</ul>
<p>Unfortunately, applications that use Ruby and <span class="caps">AMQP</span> are not immune to these problems and developers need to always keep thatin mind. This list is just as relevant in 2011 as it was in the 90s.</p>
<p>Ruby amqp gem 0.8.x and later lets applications to define handlers that handle connection-level exceptions, channel-levelexceptions and <span class="caps">TCP</span> connection failures. Handling <span class="caps">AMQP</span> exceptions and network connection failures is relatively easy.Re-declaring <span class="caps">AMQP</span> instances application works with is where the most of complexity comes from. By using Ruby objects aserror handlers, declaration of <span class="caps">AMQP</span> entities can be done in one place, making it much easier to understand and maintain.</p>
<p>amqp gem error handling and interruption is not a copy of RabbitMQ Java client&#8217;s <a href="http://www.rabbitmq.com/api-guide.html#shutdown,but">Shutdown Protocol</a> they turn out to be similar with respect to network failures and connection-level exceptions.</p>
<p><span class="caps">TBD</span></p>
<h2>Authors</h2>
This guide was written by
<a href='http://twitter.com/michaelklishin'>
  Michael Klishin
</a>
and edited by
<a href='https://twitter.com/celldee'>
  Chris Duncan
</a>
<h2>Tell us what you think!</h2>
<p>
  Please take a moment to tell us what you think about this guide
  <a href='http://twitter.com/rubyamqp'>
    on Twitter
  </a>
  or the
  <a href='http://groups.google.com/group/ruby-amqp.'>
    Ruby AMQP mailing list
  </a>
</p>
<p>
  Let us know what was unclear or what has not been covered. Maybe you do not like the guide style or grammar or discover spelling mistakes. Reader feedback is key to making the documentation better.
</p>
<p>
  If, for some reason, you cannot use the communication channels mentioned above, you can
  <a href='mailto:michaelklishin@me.com?subject=amqp%20gem%20documentation'>
    contact the author of the guides directly
  </a>
</p>
<div id='disqus_thread'></div>
<script type='text/javascript'>
  //<![CDATA[
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'rubyamqpdocs'; // required: replace example with your forum shortname
    
    var disqus_developer = 0; // set to 1 on local machine for testing comments
    = "var disqus_identifier = 'amqp_error_handling';"
    = "var disqus_url = 'http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/ErrorHandling.textile';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  //]]>
</script></article></section></body></html>