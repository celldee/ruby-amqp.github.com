<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><head>
  <title>
    Ruby amqp gem:
    Working with queues
  </title>
  <link href='/assets/stylesheets/sass/styles.css' media='screen' rel='stylesheet' type='text/css' />
</head>
<script src='/assets/javascripts/jquery-1.7.min.js' type='text/javascript'></script>
<script src='/assets/javascripts/codemirror.js'></script>
<script src='/assets/javascripts/toc.js'></script>
<script src='/assets/javascripts/code_highlight.js'></script>
<link href='/assets/stylesheets/codemirror.css' rel='stylesheet' />
<script src='/assets/javascripts/mode/ruby.js'></script>
<link href='/assets/stylesheets/theme/default.css' rel='stylesheet' />
<script type='text/javascript'>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27153041-1']);
  _gaq.push(['_trackPageview']);
  (function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script><body><div class='topbar'>
  <div class='topbar-inner'>
    <div class='container'>
      <ul class='nav'>
        <li>
          <a href='/'>
            Home
          </a>
        </li>
        <li>
          <a href='/articles/getting_started/'>
            Getting Started
          </a>
        </li>
        <li>
          <a href='/articles/amqp_9_1_model_explained/'>
            AMQP 0.9.1 Model
          </a>
        </li>
        <li>
          <a href='/articles/connecting_to_broker/'>
            Connecting
          </a>
        </li>
        <li>
          <a href='/articles/working_with_queues/'>
            Queues
          </a>
        </li>
        <li>
          <a href='/articles/working_with_exchanges/'>
            Exchanges
          </a>
        </li>
        <li>
          <a href='/articles/patterns_and_use_cases/'>
            Patterns & Use Cases
          </a>
        </li>
        <li>
          <a href='/articles/error_handling/'>
            Error Handling
          </a>
        </li>
      </ul>
    </div>
  </div>
</div><section class='content'><article><div class='toc'></div>
<h1>Working with queues</h1>
<h2>About this guide</h2>
<p>This guide covers everything related to queues in the <span class="caps">AMQP</span> v0.9.1 specification, common usage scenarios and how to accomplish typical operations using the amqp gem. This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a> (including images &amp; stylesheets). The source is available <a href="https://github.com/ruby-amqp/amqp/tree/master/docs">on Github</a>.</p>
<h2>Which versions of the amqp gem does this guide cover?</h2>
<p>This guide covers v0.8.0 and later of the <a href="http://github.com/ruby-amqp/amqp">Ruby amqp gem</a>.</p>
<h2>Queues in <span class="caps">AMQP</span> v0.9.1 &#8211; overview</h2>
<h3>What are <span class="caps">AMQP</span> queues?</h3>
<p><span class="note">Queues</span> store and forward messages to consumers. They are similar to mailboxes in <span class="caps">SMTP</span>. Messages flow from producing applications to <a href="/articles/working_with_exchanges/">exchanges</a> that route them to queues and finally queues deliver the messages to consumer applications (or consumer applications fetch messages as needed).</p>
<p>Note that unlike some other messaging protocols/systems, messages are not delivered directly to queues. They are delivered to exchanges that route messages to queues using rules known as <span class="note">bindings</span>.</p>
<p><span class="caps">AMQP</span> is a programmable protocol, so queues and bindings alike are declared by applications.</p>
<h3>Concept of bindings</h3>
<p>A <span class="note">binding</span> is an association between a queue and an exchange. Queues must be bound to at least one exchange in order to receive messages from publishers. Learn more about bindings in the <a href="/articles/bindings/">Bindings guide</a>.</p>
<h3>Queue attributes</h3>
<p>Queues have several attributes associated with them:</p>
<ul>
	<li>Name</li>
	<li>Exclusivity</li>
	<li>Durability</li>
	<li>Whether the queue is auto-deleted when no longer used</li>
	<li>Other metadata (sometimes called <span class="note">X-arguments</span>)</li>
</ul>
<p>These attributes define how queues can be used, what their life-cycle is like and other aspects of queue behavior.</p>
<p>The amqp gem represents queues as instances of <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue"><span class="caps">AMQP</span>::Queue</a>.</p>
<h2>Queue names and declaring queues</h2>
<p>Every <span class="caps">AMQP</span> queue has a name that identifies it. Queue names often contain several segments separated by a dot &#8220;.&#8221;, in a similar fashion to <span class="caps">URI</span> path segments being separated by a slash &#8220;/&#8221;, although almost any string can represent a segment (with some limitations &#8211; see below).</p>
<p>Before a queue can be used, it has to be <strong>declared</strong>. Declaring a queue will cause it to be created if it does not already exist. The declaration will have no effect if the queue does already exist and its attributes are the <strong>same as those in the declaration</strong>. When the existing queue attributes are not the same as those in the declaration a channel-level exception is raised. This case is explained later in this guide.</p>
<h3>Explicitly named queues</h3>
<p>Applications may pick queue names or ask the broker to generate a name for them.</p>
<p>To declare a queue with a particular name, for example, &#8220;images.resize&#8221;, pass it to the Queue class constructor:</p>
<pre>queue = AMQP::Queue.new(channel, "images.resize", :auto_delete =&gt; true)</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Declaring a queue with explicitly given name using AMQP::Queue constructor
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  queue   = AMQP::Queue.new(channel, "images.resize", :auto_delete =&gt; true)

  puts "#{queue.name} is ready to go."

  connection.close {
    EventMachine.stop { exit }
  }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998721">gist</a>)</span></p>
<h3>Server-named queues</h3>
<p>To ask an <span class="caps">AMQP</span> broker to generate a unique queue name for you, pass an <strong>empty string</strong> as the queue name argument:</p>
<pre>AMQP::Queue.new(channel, "", :auto_delete =&gt; true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go. AMQP method: #{declare_ok.inspect}"
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Declaring a queue with server-generated name using AMQP::Queue constructor
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  AMQP::Queue.new(channel, "", :auto_delete =&gt; true) do |queue|
    puts "#{queue.name} is ready to go."

    connection.close {
      EventMachine.stop { exit }
    }
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998720">gist</a>)</span></p>
<p>The amqp gem allows server-named queues to be declared without callbacks:</p>
<pre>queue = AMQP::Queue.new(channel, "", :auto_delete =&gt; true)</pre>
<p>In this case, as soon as the <span class="caps">AMQP</span> broker reply (`queue.declare-ok` <span class="caps">AMQP</span> method) arrives, the queue object name will be assigned to the value that the broker generated. Many <span class="caps">AMQP</span> operations require a queue name, so before an <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue"><span class="caps">AMQP</span>::Queue</a> instance receives its name, those operations are delayed. This example demonstrates this:</p>
<pre>queue = channel.queue("")
queue.bind("builds").subscribe do |metadata, payload|
  # message handling implementation...
end</pre>
<p>In this example, binding will be performed as soon as the queue has received its name generated by the broker.</p>
<p>If a particular piece of code relies on the queue name being available immediately a callback should be used.</p>
<h3>Reserved queue name prefix</h3>
<p>Queue names starting with &#8220;amq.&#8221; are reserved for internal use by the broker. Attempts to declare a queue with a name that violates this rule will result in a channel-level exception with reply code 403 (ACCESS_REFUSED) and a reply message similar to this:</p>
<p><code>ACCESS_REFUSED - queue name 'amq.queue' contains reserved prefix 'amq.*'</code></p>
<h3>Queue re-declaration with different attributes</h3>
<p>When queue declaration attributes are different from those that the queue already has, a channel-level exception with code 406 (PRECONDITION_FAILED) will be raised. The reply text will be similar to this:</p>
<p><code>PRECONDITION_FAILED - parameters for queue 'amqpgem.examples.channel_exception' in vhost '/' not equivalent</code></p>
<h2>Queue life-cycle patterns</h2>
<p>According to the <span class="caps">AMQP</span> v0.9.1 specification, there are two common message queue life-cycle patterns:</p>
<ul>
	<li>Durable message queues that are shared by many consumers and have an independent existence: i.e. they will continue to exist and collect messages whether or not there are consumers to receive them.</li>
	<li>Temporary message queues that are private to one consumer and are tied to that consumer. When the consumer disconnects, the message queue is deleted.</li>
</ul>
<p>There are some variations of these, such as shared message queues that are deleted when the last of many consumers disconnects.</p>
<p>Let us examine the example of a well-known service like an event collector (event logger). A logger is usually up and running regardless of the existence of services that want to log anything at a particular point in time. Other applications know which queues to use in order to communicate with the logger and can rely on those queues being available and able to survive broker restarts. In this case, explicitly named durable queues are optimal and the coupling that is created between applications is not an issue.</p>
<p>Another example of a well-known long-lived service is a distributed metadata/directory/locking server like <a href="http://zookeeper.apache.org">Apache Zookeeper</a>, <a href="http://labs.google.com/papers/chubby.html">Google&#8217;s Chubby</a> or <span class="caps">DNS</span>. Services like this benefit from using well-known, not server-generated, queue names and so do any other applications that use them.</p>
<p>A different sort of scenario is in &#8220;a cloud setting&#8221; when some kind of worker/instance might start and stop at any time so that other applications cannot rely on it being available. In this case, it is possible to use well-known queue names, but a much better solution is to use server-generated, short-lived queues that are bound to topic or fanout exchanges in order to receive relevant messages.</p>
<p>Imagine a service that processes an endless stream of events &#8211; Twitter is one example. When traffic increases, development operations may start additional application instances in the cloud to handle the load. Those new instances want to subscribe to receive messages to process, but the rest of the system does not know anything about them and cannot rely on them being online or try to address them directly. The new instances process events from a shared stream and are the same as their peers. In a case like this, there is no reason for message consumers not to use queue names generated by the broker.</p>
<p>In general, use of explicitly named or server-named queues depends on the messaging pattern that your application needs. {http://www.eaipatterns.com/ Enterprise Integration Patterns} discusses many messaging patterns in depth and the RabbitMQ <span class="caps">FAQ</span> also has a section on {http://www.rabbitmq.com/faq.html#scenarios use cases}.</p>
<h2>Declaring a durable shared queue</h2>
<p>To declare a durable shared queue, you pass a queue name that is a non-blank string and use the &#8220;:durable&#8221; option:</p>
<pre>queue = AMQP::Queue.new(channel, "images.resize", :durable =&gt; true)</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Declaring a durable shared queue
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  queue   = AMQP::Queue.new(channel, "images.resize", :durable =&gt; true)

  connection.close {
    EventMachine.stop { exit }
  }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998723">gist</a>)</span></p>
<p>the same example rewritten to use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#queue-instance_method"><span class="caps">AMQP</span>::Channel#queue</a>:</p>
<pre>channel.queue("images.resize", :durable =&gt; true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go."
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Declaring a durable shared queue using AMQP::Channel#queue method
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  queue   = channel.queue("images.resize", :durable =&gt; true)

  connection.close {
    EventMachine.stop { exit }
  }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998724">gist</a>)</span></p>
<h2>Declaring a temporary exclusive queue</h2>
<p>To declare a server-named, exclusive, auto-deleted queue, pass &quot;&quot; (empty string) as the queue name and use the &#8220;:exclusive&#8221; and &#8220;:auto_delete&#8221; options:</p>
<pre>AMQP::Queue.new(channel, "", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go."
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Declaring a temporary exclusive queue
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)

  AMQP::Queue.new(channel, "", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    puts "#{queue.name} is ready to go."

    connection.close {
      EventMachine.stop { exit }
    }
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998725">gist</a>)</span></p>
<p>The same example can be rewritten to use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#queue-instance_method"><span class="caps">AMQP</span>::Channel#queue</a>:</p>
<pre>channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
  puts "#{queue.name} is ready to go."
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Declaring a temporary exclusive queue
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  AMQP::Channel.new do |channel, open_ok|
    channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
      puts "#{queue.name} is ready to go."

      connection.close {
        EventMachine.stop { exit }
      }
    end
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998726">gist</a>)</span></p>
<p>Exclusive queues may only be accessed by the current connection and are deleted when that connection closes. The declaration of an exclusive queue by other connections is not allowed and will result in a channel-level exception with the code 405 (RESOURCE_LOCKED) and a reply message similar to</p>
<pre>require "rubygems"
require 'amqp'


puts "=&gt; Queue exclusivity violation results "

EventMachine.run do
  connection1 = AMQP.connect("amqp://guest:guest@dev.rabbitmq.com")
  channel1    = AMQP::Channel.new(connection1)

  connection2 = AMQP.connect("amqp://guest:guest@dev.rabbitmq.com")
  channel2    = AMQP::Channel.new(connection2)

  channel1.on_error do |ch, close|
    puts "Handling a channel-level exception on channel1: #{close.reply_text}, #{close.inspect}"
  end
  channel2.on_error do |ch, close|
    puts "Handling a channel-level exception on channel2: #{close.reply_text}, #{close.inspect}"
  end

  name = "amqpgem.examples.queue"
  channel1.queue(name, :auto_delete =&gt; true, :exclusive =&gt; true)
  # declare a queue with the same name on a different connection
  channel2.queue(name, :auto_delete =&gt; true, :exclusive =&gt; true)


  EventMachine.add_timer(3.5) do
    connection1.close {
      connection2.close {
        EventMachine.stop { exit }
      }
    }
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1008529">gist</a>)</span></p>
<h2>Binding queues to exchanges</h2>
<p>In order to receive messages, a queue needs to be bound to at least one exchange. Most of the time binding is explcit (done by applications). To bind a queue to an exchange, use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#bind-instance_method"><span class="caps">AMQP</span>::Queue#bind</a> where the argument passed can be either an <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Exchange"><span class="caps">AMQP</span>::Exchange</a> instance or a string.</p>
<pre>queue.bind(exchange) do |bind_ok|
  puts "Just bound #{queue.name} to #{exchange.name}"
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Binding a queue to an exchange
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel  = AMQP::Channel.new(connection)
  exchange = channel.fanout("amq.fanout")

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    queue.bind(exchange) do |bind_ok|
      puts "Just bound #{queue.name} to #{exchange.name}"
    end

    connection.close {
      EventMachine.stop { exit }
    }
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998727">gist</a>)</span></p>
<p>The same example using a string without callback:</p>
<pre>queue.bind("amq.fanout")</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

# Binding a queue to an exchange
AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  exchange_name = "amq.fanout"

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    queue.bind(exchange_name)
    puts "Bound #{queue.name} to #{exchange_name}"

    connection.close {
      EventMachine.stop { exit }
    }
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998729">gist</a>)</span></p>
<h2>Subscribing to receive messages (&#8220;push <span class="caps">API</span>&#8221;)</h2>
<p>To set up a queue subscription to enable an application to receive messages as they arrive in a queue, one uses the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#subscribe-instance_method"><span class="caps">AMQP</span>::Queue#subscribe</a> method. Then when a message arrives, the message header (metadata) and body (payload) are passed to the handler:</p>
<pre>queue.subscribe do |metadata, payload|
  puts "Received a message: #{payload.inspect}."
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel  = AMQP::Channel.new(connection)
  exchange = channel.fanout("amq.fanout")

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue|
    queue.bind(exchange).subscribe do |metadata, payload|
      puts "Received a message: #{payload.inspect}. Shutting down..."

      connection.close { EventMachine.stop }
    end

    EventMachine.add_timer(0.2) do
      puts "=&gt; Publishing..."
      exchange.publish("Ohai!")
    end
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998731">gist</a>)</span></p>
<p>Subscriptions for message delivery are usually referred to as <span class="note">consumers</span> in the <span class="caps">AMQP</span> v0.9.1 specification, client library documentation and books. Consumers last as long as the channel that they were declared on, or until  client cancels them (unsubscribes).</p>
<p>Consumers are identified by <span class="note">consumer tags</span>. If you need to obtain the consumer tag of a subscribed queue then use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#consumer_tag-instance_method"><span class="caps">AMQP</span>::Queue#consumer_tag</a>.</p>
<h3>Accessing message metadata</h3>
<p>The <span class="note">header</span> object in the example above provides access to message metadata and delivery information:</p>
<ul>
	<li>Message content type</li>
	<li>Message content encoding</li>
	<li>Message routing key</li>
	<li>Message delivery mode (persistent or not)</li>
	<li>Consumer tag this delivery is for</li>
	<li>Delivery tag</li>
	<li>Message priority</li>
	<li>Whether or not message is redelivered</li>
	<li>Producer application id</li>
</ul>
<p>and so on. An example to demonstrate how to access some of those attributes:</p>
<pre># producer
exchange.publish("Hello, world!",
                 :app_id      =&gt; "amqpgem.example",
                 :priority    =&gt; 8,
                 :type        =&gt; "kinda.checkin",
                 # headers table keys can be anything
                 :headers     =&gt; {
                   :coordinates =&gt; {
                     :latitude  =&gt; 59.35,
                     :longitude =&gt; 18.066667
                   },
                   :participants =&gt; 11,
                   :venue        =&gt; "Stockholm"
                 },
                 :timestamp   =&gt; Time.now.to_i)
</pre>

<pre># consumer
queue.subscribe do |metadata, payload|
  puts "metadata.routing_key : #{metadata.routing_key}"
  puts "metadata.content_type: #{metadata.content_type}"
  puts "metadata.priority    : #{metadata.priority}"
  puts "metadata.headers     : #{metadata.headers.inspect}"
  puts "metadata.timestamp   : #{metadata.timestamp.inspect}"
  puts "metadata.type        : #{metadata.type}"
  puts "metadata.delivery_tag: #{metadata.delivery_tag}"
  puts "metadata.redelivered : #{metadata.redelivered?}"

  puts "metadata.app_id      : #{metadata.app_id}"
  puts "metadata.exchange    : #{metadata.exchange}"
  puts
  puts "Received a message: #{payload}."
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "bundler"
Bundler.setup

$:.unshift(File.expand_path("../../../lib", __FILE__))

require 'amqp'

EventMachine.run do
  connection = AMQP.connect(:host =&gt; '127.0.0.1')
  puts "Connected to AMQP broker. Running #{AMQP::VERSION} version of the gem..."

  channel  = AMQP::Channel.new(connection)
  queue    = channel.queue("amqpgem.examples.hello_world", :auto_delete =&gt; true)
  exchange = channel.direct("amq.direct")

  queue.bind(exchange)

  channel.on_error do |ch, channel_close|
    puts channel_close.reply_text
    connection.close { EventMachine.stop }
  end

  queue.subscribe do |metadata, payload|
    puts "metadata.routing_key : #{metadata.routing_key}"
    puts "metadata.content_type: #{metadata.content_type}"
    puts "metadata.priority    : #{metadata.priority}"
    puts "metadata.headers     : #{metadata.headers.inspect}"
    puts "metadata.timestamp   : #{metadata.timestamp.inspect}"
    puts "metadata.type        : #{metadata.type}"
    puts "metadata.delivery_tag: #{metadata.delivery_tag}"
    puts "metadata.redelivered : #{metadata.redelivered}"

    puts "metadata.app_id      : #{metadata.app_id}"
    puts "metadata.exchange    : #{metadata.exchange}"
    puts
    puts "Received a message: #{payload}. Disconnecting..."

    connection.close {
      EventMachine.stop { exit }
    }
  end

  exchange.publish("Hello, world!",
                   :app_id      =&gt; "amqpgem.example",
                   :priority    =&gt; 8,
                   :type        =&gt; "kinda.checkin",
                   # headers table keys can be anything
                   :headers     =&gt; {
                     :coordinates =&gt; {
                       :latitude  =&gt; 59.35,
                       :longitude =&gt; 18.066667
                     },
                     :participants =&gt; 11,
                     :venue        =&gt; "Stockholm"
                   },
                   :timestamp   =&gt; Time.now.to_i)
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998739">gist</a>)</span></p>
<h3>Exclusive consumers</h3>
<p>Consumers can request exclusive access to the queue (meaning only this consumer can access the queue). This is useful when you want a long-lived shared queue to be temporarily accessible by just one application (or thread, or process). If the application employing the exclusive consumer crashes or loses the <span class="caps">TCP</span> connection to the broker, then the channel is closed and the exclusive consumer is cancelled.</p>
<p>To exclusively receive messages from the queue, pass the &#8220;:exclusive&#8221; option to <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#subscribe-instance_method"><span class="caps">AMQP</span>::Queue#subscribe</a>:</p>
<pre>queue.subscribe(:exclusive =&gt; true) do |metadata, payload|
  # message handling logic...
end</pre>
<p><span class="caps">TBD</span>: describe what happens when exclusivity property is violated and how to handle it.</p>
<h3>Using multiple consumers per queue</h3>
<p>Historically, amqp gem versions before v0.8.0.RC14 (current master branch in the repository) have had a &#8220;one consumer per Queue instance&#8221; limitation. Previously, to work around this problem, application developers had to open multiple channels and work with multiple queue instances on different channels. This is not very convenient and is surprising for developers familiar with <span class="caps">AMQP</span> clients for other languages.</p>
<p>With more and more Ruby implementations dropping the <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock"><span class="caps">GIL</span></a>, load balancing between multiple consumers in the same queue in the same OS process has become more and more common. In certain cases, even applications that do not need any concurrency benefit from having multiple consumers on the same queue in the same process.</p>
<p>Starting from amqp gem v0.8.0.RC14, it is possible to add any number of consumers by instantiating {AMQP::Consumer} directly:</p>
<pre># non-exclusive consumer, consumer tag is generated
consumer1 = AMQP::Consumer.new(channel, queue)

# non-exclusive consumer, consumer tag is explicitly given
consumer2 = AMQP::Consumer.new(channel, queue, "#{queue.name}-consumer-#{rand}-#{Time.now}")

# exclusive consumer, consumer tag is generated
consumer3 = AMQP::Consumer.new(channel, queue, nil, true)</pre>
<p>Instantiated consumers do not begin consuming messages immediately. This is because in certain cases, it is useful to add a consumer but make it active at a later time. To consume messages, use the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Consumer#consume-instance_method"><span class="caps">AMQP</span>::Consumer#consume</a> method in combination with <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Consumer#on_delivery-instance_method"><span class="caps">AMQP</span>::Consumer#on_delivery</a>:</p>
<pre>consumer1.consume.on_delivery do |metadata, payload|
  @consumer1_mailbox &lt;&lt; payload
end</pre>
<p><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Consumer#on_delivery-instance_method"><span class="caps">AMQP</span>::Consumer#on_delivery</a> takes a block that is used exactly like the block passed to <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#subscribe-instance_method"><span class="caps">AMQP</span>::Queue#subscribe</a>. In fact, <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#subscribe-instance_method"><span class="caps">AMQP</span>::Queue#subscribe</a> uses <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Consumer"><span class="caps">AMQP</span>::Consumer</a> under the hood, adding a <span class="note">default consumer</span> to the queue.</p>
<p><span class="help-block"><br />
Default consumers do not have any special properties, they just provide a convenient way for application developers to register multiple consumers and a means of preserving backwards compatibility. Application developers are always free to use <span class="caps">AMQP</span>::Consumer instances directly, or intermix them with <span class="caps">AMQP</span>::Queue#subscribe.<br />
</span></p>
<p>Most of the public <span class="caps">API</span> methods on <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Consumer"><span class="caps">AMQP</span>::Consumer</a> return self, so it is possible to use method chaining extensively. An example from <a href="https://github.com/ruby-amqp/amqp/tree/master/spec">amqp gem spec suite</a>:</p>
<pre>consumer1 = AMQP::Consumer.new(@channel, @queue).consume.on_delivery { |metadata, payload| mailbox1 &lt;&lt; payload }
consumer2 = AMQP::Consumer.new(@channel, @queue).consume.on_delivery { |metadata, payload| mailbox2 &lt;&lt; payload }</pre>
<p>To cancel a particular consumer, use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Consumer#cancel-instance_method"><span class="caps">AMQP</span>::Consumer#cancel</a> method. To cancel a default queue consumer, use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#unsubscribe-instance_method"><span class="caps">AMQP</span>::Queue#unsubscribe</a>.</p>
<h3>Message acknowledgements</h3>
<p>Consumer applications &#8211; applications that receive and process messages &#8211; may occasionally fail to process individual messages, or will just crash. There is also the possibility of network issues causing problems. This raises a question &#8211; &#8220;When should the <span class="caps">AMQP</span> broker remove messages from queues?&#8221; The <span class="caps">AMQP</span> v0.9.1 specification proposes two choices:</p>
<ul>
	<li>After broker sends a message to an application (using either basic.deliver or basic.get-ok methods).</li>
	<li>After the application sends back an acknowledgement (using basic.ack <span class="caps">AMQP</span> method).</li>
</ul>
<p>The former choice is called the <strong>automatic acknowledgement model</strong>, while the latter is called the <strong>explicit acknowledgement model</strong>. With the explicit model, the application chooses when it is time to send an acknowledgement. It can be right after receiving a message, or after persisting it to a data store before processing, or after fully processing the message (for example, successfully fetching a Web page, processing and storing it into some persistent data store).</p>
<p><img src="https://github.com/ruby-amqp/amqp/raw/master/docs/diagrams/006_amqp_091_message_acknowledgements.png" alt="" /></p>
<p>If a consumer dies without sending an acknowledgement, the <span class="caps">AMQP</span> broker will redeliver it to another consumer, or, if none are available at the time, the broker will wait until at least one consumer is registered for the same queue before attempting redelivery.</p>
<p>The acknowledgement model is chosen when a new consumer is registered for a queue. By default, <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#subscribe-instance_method"><span class="caps">AMQP</span>::Queue#subscribe</a> will use the <strong>automatic</strong> model. To switch to the <strong>explicit</strong> model, the &#8220;:ack&#8221; option should<br />
be used:</p>
<pre>queue.subscribe(:ack =&gt; true) do |metadata, payload|
  # message handling logic...
end</pre>
<p>To demonstrate how redelivery works, let us have a look at the following code example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "bundler"
Bundler.setup

$:.unshift(File.expand_path("../../../lib", __FILE__))

require 'amqp'

puts "=&gt; Subscribing for messages using explicit acknowledgements model"
puts

# this example uses Kernel#sleep and thus we must run EventMachine reactor in
# a separate thread, or nothing will be sent/received while we sleep() on the current thread.
t = Thread.new { EventMachine.run }
sleep(0.5)

# open two connections to imitate two apps
connection1 = AMQP.connect
connection2 = AMQP.connect
connection3 = AMQP.connect

channel_exception_handler = Proc.new { |ch, channel_close| EventMachine.stop; raise "channel error: #{channel_close.reply_text}" }

# open two channels
channel1    = AMQP::Channel.new(connection1)
channel1.on_error(&amp;channel_exception_handler)
# first app will be given up to 3 messages at a time. If it doesn't
# ack any messages after it was delivered 3, messages will be routed to
# the app #2.
channel1.prefetch(3)

channel2    = AMQP::Channel.new(connection2)
channel2.on_error(&amp;channel_exception_handler)
# app #2 processes messages one-by-one and has to send and ack every time
channel2.prefetch(1)

# app 3 will just publish messages
channel3    = AMQP::Channel.new(connection3)
channel3.on_error(&amp;channel_exception_handler)

exchange = channel3.direct("amq.direct")

queue1    = channel1.queue("amqpgem.examples.acknowledgements.explicit", :auto_delete =&gt; false)
# purge the queue so that we don't get any redeliveries from previous runs
queue1.purge
queue1.bind(exchange).subscribe(:ack =&gt; true) do |metadata, payload|
  # do some work
  sleep(0.2)

  # acknowledge some messages, they will be removed from the queue
  if rand &gt; 0.5
    # FYI: there is a shortcut, metadata.ack
    channel1.acknowledge(metadata.delivery_tag, false)
    puts "[consumer1] Got message ##{metadata.headers['i']}, ack-ed"
  else
    # some messages are not ack-ed and will remain in the queue for redelivery
    # when app #1 connection is closed (either properly or due to a crash)
    puts "[consumer1] Got message ##{metadata.headers['i']}, SKIPPPED"
  end
end

queue2    = channel2.queue!("amqpgem.examples.acknowledgements.explicit", :auto_delete =&gt; false)
queue2.subscribe(:ack =&gt; true) do |metadata, payload|
  metadata.ack
  # app 2 always acks messages
  puts "[consumer2] Received #{payload}, redelivered = #{metadata.redelivered}, ack-ed"
end

# after 2.5 seconds one of the consumers dies
EventMachine.add_timer(4.0) {
  connection1.close
  puts "----- Connection 1 is now closed (we pretend that it has crashed) -----"
}

EventMachine.add_timer(10.0) do
  # purge the queue so that we don't get any redeliveries on the next run
  queue2.purge {
    connection2.close {
      connection3.close { EventMachine.stop }
    }
  }
end


i = 0
EventMachine.add_periodic_timer(0.8) {
  3.times do
    exchange.publish("Message ##{i}", :headers =&gt; { :i =&gt; i })
    i += 1
  end
}


t.join
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/999396">gist</a>)</span></p>
<p>So what is going on here? This example uses 3 <span class="caps">AMQP</span> connections to imitate 3 applications, 1 producer and two consumers. Each <span class="caps">AMQP</span> connection opens a single channel:</p>
<pre># open three connections to imitate three apps
connection1 = AMQP.connect
connection2 = AMQP.connect
connection3 = AMQP.connect

channel_exception_handler = Proc.new { |ch, channel_close| EventMachine.stop; raise "channel error: #{channel_close.reply_text}" }

# open two channels
channel1    = AMQP::Channel.new(connection1)
channel1.on_error(&amp;channel_exception_handler)
# ...

channel2    = AMQP::Channel.new(connection2)
channel2.on_error(&amp;channel_exception_handler)
# ...

# app 3 will just publish messages
channel3    = AMQP::Channel.new(connection3)
channel3.on_error(&amp;channel_exception_handler)</pre>
<p>The consumers share a queue and the producer publishes messages to the queue periodically using an <span class="note">`amq.direct`</span> exchange. Both &#8220;applications&#8221; subscribe to receive messages using the explicit acknowledgement model. The <span class="caps">AMQP</span> broker by default will send each message to the next consumer in sequence (this kind of load balancing is known as <strong>round-robin</strong>). This means that some messages will be delivered to consumer #1 and some to consumer #2.</p>
<pre>exchange = channel3.direct("amq.direct")

# ...

queue1    = channel1.queue("amqpgem.examples.acknowledgements.explicit", :auto_delete =&gt; false)
# purge the queue so that we do not get any redeliveries from previous runs
queue1.purge
queue1.bind(exchange).subscribe(:ack =&gt; true) do |metadata, payload|
  # do some work
  sleep(0.2)

  # acknowledge some messages, they will be removed from the queue
  if rand &gt; 0.5
    # FYI: there is a shortcut, metadata.ack
    channel1.acknowledge(metadata.delivery_tag, false)
    puts "[consumer1] Got message ##{metadata.headers['i']}, ack-ed"
  else
    # odd messages are not ack-ed and will remain in the queue for redelivery
    # when app #1 connection is closed (either properly or due to a crash)
    puts "[consumer1] Got message ##{metadata.headers['i']}, SKIPPED"
  end
end

queue2    = channel2.queue!("amqpgem.examples.acknowledgements.explicit", :auto_delete =&gt; false)
queue2.subscribe(:ack =&gt; true) do |metadata, payload|
  metadata.ack
  # app 2 always acks messages
  puts "[consumer2] Received #{payload}, redelivered = #{metadata.redelivered}, ack-ed"
end</pre>
<p>To demonstrate message redelivery we make consumer #1 randomly select which messages to acknowledge. After 4 seconds we disconnect it (to imitate a crash). When that happens, the <span class="caps">AMQP</span> broker redelivers unacknowledged messages to consumer #2 which acknowledges them unconditionally. After 10 seconds, this example closes all outstanding connections and exits.</p>
<p>An extract of output produced by this example:</p>
<p><code>=&gt; Subscribing for messages using explicit acknowledgements model
[consumer2] Received Message #0, redelivered = false, ack-ed
[consumer1] Got message #1, SKIPPED
[consumer1] Got message #2, SKIPPED
[consumer1] Got message #3, ack-ed
[consumer2] Received Message #4, redelivered = false, ack-ed
[consumer1] Got message #5, SKIPPED
[consumer2] Received Message #6, redelivered = false, ack-ed
[consumer2] Received Message #7, redelivered = false, ack-ed
[consumer2] Received Message #8, redelivered = false, ack-ed
[consumer2] Received Message #9, redelivered = false, ack-ed
[consumer2] Received Message #10, redelivered = false, ack-ed
[consumer2] Received Message #11, redelivered = false, ack-ed
----- Connection 1 is now closed (we pretend that it has crashed) -----
[consumer2] Received Message #5, redelivered = true, ack-ed
[consumer2] Received Message #1, redelivered = true, ack-ed
[consumer2] Received Message #2, redelivered = true, ack-ed
[consumer2] Received Message #12, redelivered = false, ack-ed
[consumer2] Received Message #13, redelivered = false, ack-ed
[consumer2] Received Message #14, redelivered = false, ack-ed
[consumer2] Received Message #15, redelivered = false, ack-ed
[consumer2] Received Message #16, redelivered = false, ack-ed
[consumer2] Received Message #17, redelivered = false, ack-ed
[consumer2] Received Message #18, redelivered = false, ack-ed
[consumer2] Received Message #19, redelivered = false, ack-ed
[consumer2] Received Message #20, redelivered = false, ack-ed
[consumer2] Received Message #21, redelivered = false, ack-ed
[consumer2] Received Message #22, redelivered = false, ack-ed
[consumer2] Received Message #23, redelivered = false, ack-ed
[consumer2] Received Message #24, redelivered = false, ack-ed
[consumer2] Received Message #25, redelivered = false, ack-ed
[consumer2] Received Message #26, redelivered = false, ack-ed
[consumer2] Received Message #27, redelivered = false, ack-ed
[consumer2] Received Message #28, redelivered = false, ack-ed
[consumer2] Received Message #29, redelivered = false, ack-ed
[consumer2] Received Message #30, redelivered = false, ack-ed
[consumer2] Received Message #31, redelivered = false, ack-ed
[consumer2] Received Message #32, redelivered = false, ack-ed
[consumer2] Received Message #33, redelivered = false, ack-ed
[consumer2] Received Message #34, redelivered = false, ack-ed
[consumer2] Received Message #35, redelivered = false, ack-ed</code></p>
<p>As we can see, consumer #1 did not acknowledge 3 messages (labelled 1, 2 and 5):</p>
<p><code>[consumer1] Got message #1, SKIPPED
[consumer1] Got message #2, SKIPPED
...
[consumer1] Got message #5, SKIPPED </code></p>
<p>and then, once consumer #1 had &#8220;crashed&#8221;, those messages were immediately redelivered to the consumer #2:</p>
<p><code>Connection 1 is now closed (we pretend that it has crashed)
[consumer2] Received Message #5, redelivered = true, ack-ed
[consumer2] Received Message #1, redelivered = true, ack-ed
[consumer2] Received Message #2, redelivered = true, ack-ed </code></p>
<p>To acknowledge a message use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#acknowledge-instance_method"><span class="caps">AMQP</span>::Channel#acknowledge</a>:</p>
<pre>channel1.acknowledge(metadata.delivery_tag, false)</pre>
<p><a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#acknowledge-instance_method"><span class="caps">AMQP</span>::Channel#acknowledge</a> takes two arguments: message <strong>delivery tag</strong> and a flag that indicates whether or not we want to acknowledge multiple messages at once. Delivery tag is simply a channel-specific increasing number that the server uses to identify deliveries.</p>
<p>When acknowledging multiple messages at once, the delivery tag is treated as &#8220;up to and including&#8221;. For example, if delivery tag = 5 that would mean &#8220;acknowledge messages 1, 2, 3, 4 and 5&#8221;.</p>
<p>As a shortcut, it is possible to acknowledge messages using the {AMQP::Header#ack} method:</p>
<pre>queue2.subscribe(:ack =&gt; true) do |metadata, payload|
  metadata.ack
end</pre>
<p><span class="help-block"><br />
Acknowledgements are channel-specific. Applications must not receive messages on one channel and acknowledge them on another.<br />
</span></p>
<p><span class="help-block"><br />
A message <span class="caps">MUST</span> not be acknowledged more than once. Doing so will result in a channel-level exception (PRECONDITION_FAILED) with an error message like this: &#8220;PRECONDITION_FAILED &#8211; unknown delivery tag&#8221;<br />
</span></p>
<h3>Rejecting messages</h3>
<p>When a consumer application receives a message, processing of that message may or may not succeed. An application can indicate to the broker that message processing has failed (or cannot be accomplished at the time) by rejecting a message. When rejecting a message, an application can ask the broker to discard or requeue it.</p>
<p>To reject a message use the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel#reject-instance_method"><span class="caps">AMQP</span>::Channel#reject</a> method:</p>
<pre>queue.bind(exchange).subscribe do |metadata, payload|
  # reject but do not requeue (simply discard)
  channel.reject(metadata.delivery_tag)
end</pre>
<p>in the example above, messages are rejected without requeueing (broker will simply discard them). To requeue a rejected message, use the second argument that {AMQP::Channel#reject} takes:</p>
<pre>queue.bind(exchange).subscribe do |metadata, payload|
  # reject and requeue
  channel.reject(metadata.delivery_tag, true)
end</pre>
<p><span class="help-block"><br />
When there is only one consumer on a queue, make sure you do not create infinite message delivery loops by rejecting and requeueing a message from the same consumer over and over again.<br />
</span></p>
<p>Another way to reject a message is by using {AMQP::Header#reject}:</p>
<pre>queue.bind(exchange).subscribe do |metadata, payload|
  # reject but do not requeue (simply discard)
  metadata.reject
end</pre>

<pre>queue.bind(exchange).subscribe do |metadata, payload|
  # reject and requeue
  metadata.reject(:requeue =&gt; true)
end</pre>
<h3>Negative acknowledgements</h3>
<p>Messages are rejected with the <span class="note">`basic.reject`</span> <span class="caps">AMQP</span> method. There is one limitation that <span class="note">`basic.reject`</span> has: there is no way to reject multiple messages, as you can do with acknowledgements. However, if you are using <a href="http://rabbitmq.com">RabbitMQ</a>, then there is a solution. RabbitMQ provides an <span class="caps">AMQP</span> v0.9.1 extension known as <a href="http://www.rabbitmq.com/extensions.html#negative-acknowledgements">negative acknowledgements</a> (nacks) and the amqp gem supports this extension. For more information, please refer to the <a href="/articles/broker_specific_extensions/">Vendor-specific Extensions guide</a>.</p>
<h3>QoS &#8211; Prefetching messages</h3>
<p>For cases when multiple consumers share a queue, it is useful to be able to specify how many messages each consumer can be sent at once before sending the next acknowledgement. This can be used as a simple load balancing technique  to improve throughput if messages tend to be published in batches. For example, if a producing application sends messages every minute because of the nature of the work it is doing.</p>
<p>Imagine a website that takes data from social media sources like Twitter or Facebook during the Champions League final (or the Superbowl), and then calculates how many tweets mention a particular team during the last minute. The site could be structured as 3 applications:</p>
<ul>
	<li>A crawler that uses streaming APIs to fetch tweets/statuses, normalizes them and sends them in <span class="caps">JSON</span> for processing by other applications (&#8220;app A&#8221;).</li>
	<li>A calculator that detects what team is mentioned in a message, updates statistics and pushes an update to the Web UI once a minute (&#8220;app B&#8221;).</li>
	<li>A Web UI that fans visit to see the stats (&#8220;app C&#8221;).</li>
</ul>
<p>In this imaginary example, the &#8220;tweets per second&#8221; rate will vary, but to improve the throughput of the system and to decrease the maximum number of messages that the <span class="caps">AMQP</span> broker has to hold in memory at once, applications can be designed in such a way that application &#8220;app B&#8221;, the &#8220;calculator&#8221;, receives 5000 messages and then acknowledges them all at once. The broker will not send message 5001 unless it receives an acknowledgement.</p>
<p>In <span class="caps">AMQP</span> parlance this is know as <strong>QoS</strong> or <strong>message prefetching</strong>. Prefetching is configured on a per-channel (typically) or per-connection (rarely used) basis. To configure prefetching per channel, use the {AMQP::Channel#prefetch} method. Let us return to the example we used in the &#8220;Message acknowledgements&#8221; section:</p>
<pre># app #1 will be given up to 3 messages at a time. If it does not
# send an ack after receiving the messages, then the messages will
# be routed to app #2.
channel1.prefetch(3)

# app #2 processes messages one-by-one and has to send an ack after receiving each message
channel2.prefetch(1)</pre>
<p>In that example, one consumer prefetches 3 messages and another consumer prefetches just 1. If we take a look at the output that the example produces, we will see that `consumer1` fetched 4 messages and acknowledged 1. After that, all subsequent messages were delivered to `consumer2`:</p>
<p><code>[consumer2] Received Message #0, redelivered = false, ack-ed
[consumer1] Got message #1, SKIPPED
[consumer1] Got message #2, SKIPPED
[consumer1] Got message #3, ack-ed
[consumer2] Received Message #4, redelivered = false, ack-ed
[consumer1] Got message #5, SKIPPED
---
  by now consumer 1 has received 3 messages it did not acknowledge.
  With prefetch = 3, AMQP broker will not send it any more messages until consumer 1 sends an ack
---
[consumer2] Received Message #6, redelivered = false, ack-ed
[consumer2] Received Message #7, redelivered = false, ack-ed
[consumer2] Received Message #8, redelivered = false, ack-ed
[consumer2] Received Message #9, redelivered = false, ack-ed
[consumer2] Received Message #10, redelivered = false, ack-ed
[consumer2] Received Message #11, redelivered = false, ack-ed
</code></p>
<p><span class="help-block"><br />
The prefetching setting is ignored for consumers that do not use explicit acknowledgements.<br />
</span></p>
<h2>How message acknowledgements relate to transactions and Publisher Confirms</h2>
<p>In cases where you cannot afford to lose a single message, <span class="caps">AMQP</span> v0.9.1 applications can use one or a combination of the following protocol features:</p>
<ul>
	<li>Publisher confirms (a RabbitMQ-specific extension to <span class="caps">AMQP</span> v0.9.1)</li>
	<li>Publishing messages as immediate</li>
	<li>Transactions (noticeable overhead)</li>
</ul>
<p>This topic is covered in depth in the <a href="/articles/working_with_exchanges/">Working With Exchanges</a> guide. In this guide, we will only mention how message acknowledgements are related to <span class="caps">AMQP</span> transactions and the Publisher Confirms extension.</p>
<p>Let us consider a publisher application (P) that communications with a consumer &#169; using <span class="caps">AMQP</span> v0.9.1. Their communication can be graphically represented like this:</p>
<p><code>
-----       -----       -----
|   |   S1  |   |   S2  |   |
| P | ====&gt; | B | ====&gt; | C |
|   |       |   |       |   |
-----       -----       -----
</code></p>
<p>We have two network segments, S1 and S2. Each of them may fail. P is concerned with making sure that messages cross S1, while broker (B) and C are concerned with ensuring that messages cross S2 and are only removed from the queue when they are processed successfully.</p>
<p>Message acknowledgements cover reliable delivery over S2 as well as successful processing. For S1, P has to use transactions (a heavyweight solution) or the more lightweight Publisher Confirms RabbitMQ extension.</p>
<h2>Fetching messages when needed (&#8220;pull <span class="caps">API</span>&#8221;)</h2>
<p>The <span class="caps">AMQP</span> v0.9.1 specification also provides a way for applications to fetch (pull) messages from the queue only when necessary. For that, use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#pop-instance_method"><span class="caps">AMQP</span>::Queue#pop</a>:</p>
<pre>queue.pop do |metadata, payload|
  if payload
    puts "Fetched a message: #{payload.inspect}, content_type: #{metadata.content_type}. Shutting down..."
  else
    puts "No messages in the queue"
  end
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  exchange = channel.fanout("amq.fanout")

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    queue.bind(exchange)
    puts "Bound. Publishing a message..."
    exchange.publish("Ohai!")

    EventMachine.add_timer(0.5) do
      queue.pop do |metadata, payload|
        if payload
          puts "Fetched a message: #{payload.inspect}, content_type: #{metadata.content_type}. Shutting down..."
        else
          puts "No messages in the queue"
        end

        connection.close { EventMachine.stop }
      end
    end
  end
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998732">gist</a>)</span></p>
<p>If the queue is empty, then the `payload` argument will be nil, otherwise arguments are identical to those of the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#subscribe-instance_method"><span class="caps">AMQP</span>::Queue#subscribe</a> callback.</p>
<h2>Unsubscribing from messages</h2>
<p>Sometimes it is necessary to unsubscribe from messages without deleting a queue. To do that, use the <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#unsubscribe-instance_method"><span class="caps">AMQP</span>::Queue#unsubscribe</a> method:</p>
<pre>queue.unsubscribe</pre>
<p>By default <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#unsubscribe-instance_method"><span class="caps">AMQP</span>::Queue#unsubscribe</a> uses the &#8220;:noack&#8221; option to inform the broker that there is no need to send a confirmation. In other words, it does not expect you to pass in a callback, because the consumer tag on the  instance and the registered callback for messages are cleared immediately.</p>
<p>If an application needs to execute a piece of code after the broker response arrives, {AMQP::Queue#unsubscribe} takes an optional callback:</p>
<pre>queue.unsubscribe do |unbind_ok|
  # server response arrived, handle it if necessary...
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  exchange = channel.fanout("amq.fanout")

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    queue.bind(exchange).subscribe do |headers, payload|
      puts "Received a new message"
    end

    EventMachine.add_timer(0.3) do
      queue.unsubscribe
      puts "Unsubscribed. Shutting down..."

      connection.close { EventMachine.stop }
    end # EventMachine.add_timer
  end # channel.queue
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998734">gist</a>)</span></p>
<p>In <span class="caps">AMQP</span> parlance, unsubscribing from messages is often referred to as &#8220;cancelling a consumer&#8221;. Once a consumer is cancelled, messages will no longer be delivered to it, however, due to the asynchronous nature of the protocol, it is possible for &#8220;in flight&#8221; messages to be received after this call completes.</p>
<p>Fetching messages with <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#pop-instance_method"><span class="caps">AMQP</span>::Queue#pop</a> is still possible even after a consumer is cancelled.</p>
<h2>Unbinding queues from exchanges</h2>
<p>To unbind a queue from an exchange use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#unbind-instance_method"><span class="caps">AMQP</span>::Queue#unbind</a>:</p>
<pre>queue.unbind(exchange)</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  channel.on_error do |ch, channel_close|
    raise "Channel-level exception: #{channel_close.reply_text}"
  end

  exchange = channel.fanout("amq.fanout")

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    queue.bind(exchange)

    EventMachine.add_timer(0.5) do
      queue.unbind(exchange) do |_|
        puts "Unbound. Shutting down..."

        connection.close { EventMachine.stop }
      end
    end # EventMachine.add_timer
  end # channel.queue
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998742">gist</a>)</span></p>
<p>Note that trying to unbind a queue from an exchange that the queue was never bound to will result in a channel-level exception.</p>
<h2>Querying the number of messages in a queue</h2>
<p>It is possible to query the number of messages sitting in the queue by declaring the queue with the &#8220;:passive&#8221; attribute set. The response (`queue.declare-ok` <span class="caps">AMQP</span> method) will include the number of messages along with other attributes. However, the amqp gem provides a convenience method, <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#status-instance_method"><span class="caps">AMQP</span>::Queue#status</a>:</p>
<pre>queue.status do |number_of_messages, number_of_consumers|
  puts
  puts "# of messages in the queue #{queue.name} = #{number_of_messages}"
  puts
end</pre>
<p>Full example:</p>
<pre>require 'rubygems'
require 'amqp'

puts "=&gt; Queue#status example"
puts
AMQP.start(:host =&gt; 'localhost') do |connection|
  channel   = AMQP::Channel.new(connection)

  queue_name = "amqpgem.integration.queue.status.queue"
  exchange   = channel.fanout("amqpgem.integration.queue.status.fanout", :auto_delete =&gt; true)
  queue      = channel.queue(queue_name, :auto_delete =&gt; true).bind(exchange)

  100.times do |i|
    print "."
    exchange.publish(Time.now.to_i.to_s + "_#{i}", :key =&gt; queue_name)
  end
  $stdout.flush

  EventMachine.add_timer(0.5) do
    queue.status do |number_of_messages, number_of_consumers|
      puts
      puts "# of messages in the queue #{queue.name} = #{number_of_messages}"
      puts
      queue.purge
    end
  end


  show_stopper = Proc.new do
    $stdout.puts "Stopping..."
    connection.close { EventMachine.stop }
  end

  Signal.trap "INT", show_stopper
  EventMachine.add_timer(2, show_stopper)
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1068363">gist</a>)</span></p>
<h2>Querying the number of consumers on a queue</h2>
<p>It is possible to query the number of consumers on a queue by declaring the queue with the &#8220;:passive&#8221; attribute set. The response (`queue.declare-ok` <span class="caps">AMQP</span> method) will include the number of consumers along with other attributes. However, the amqp gem provides a convenience method, <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#status-instance_method"><span class="caps">AMQP</span>::Queue#status</a>:</p>
<pre>queue.status do |number_of_messages, number_of_consumers|
  puts
  puts "# of consumers on the queue #{queue.name} = #{number_of_consumers}"
  puts
end</pre>
<p>Full example:</p>
<pre>require 'rubygems'
require 'amqp'

puts "=&gt; Queue#status example"
puts
AMQP.start(:host =&gt; 'localhost') do |connection|
  channel   = AMQP::Channel.new(connection)

  queue_name = "amqpgem.integration.queue.status.queue"
  exchange   = channel.fanout("amqpgem.integration.queue.status.fanout", :auto_delete =&gt; true)
  queue      = channel.queue(queue_name, :auto_delete =&gt; true).bind(exchange)

  100.times do |i|
    print "."
    exchange.publish(Time.now.to_i.to_s + "_#{i}", :key =&gt; queue_name)
  end
  $stdout.flush

  EventMachine.add_timer(0.5) do
    queue.status do |number_of_messages, number_of_consumers|
      puts
      puts "# of consumer on the queue #{queue.name} = #{number_of_consumers}"
      puts
      queue.purge
    end
  end


  show_stopper = Proc.new do
    $stdout.puts "Stopping..."
    connection.close { EventMachine.stop }
  end

  Signal.trap "INT", show_stopper
  EventMachine.add_timer(2, show_stopper)
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1068377">gist</a>)</span></p>
<h2>Purging queues</h2>
<p>It is possible to purge a queue (remove all of the messages from it) using <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#purge-instance_method"><span class="caps">AMQP</span>::Queue#purge</a>:</p>
<pre>queue.purge</pre>
<p>This method takes an optional callback. However, remember that this operation is performed asynchronously. To run a piece of code when the <span class="caps">AMQP</span> broker confirms that a queue has been purged, use a callback that {AMQP::Queue#purge} takes:</p>
<pre>queue.purge do |_|
  puts "Purged #{queue.name}"
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

AMQP.start("amqp://guest:guest@dev.rabbitmq.com:5672") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  channel.on_error do |ch, channel_close|
    raise "Channel-level exception: #{channel_close.reply_text}"
  end
  exchange = channel.fanout("amq.fanout")

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    queue.purge do |_|
      puts "Purged #{queue.name}"
    end

    EventMachine.add_timer(0.5) do
      connection.close { EventMachine.stop }
    end # EventMachine.add_timer
  end # channel.queue
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998743">gist</a>)</span></p>
<p>Note that this example purges a newly declared queue with a unique server-generated name. When a queue is declared, it is empty, so for server-named queues, there is no need to purge them before they are used.</p>
<h2>Deleting queues</h2>
<p>To delete a queue, use <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#delete-instance_method"><span class="caps">AMQP</span>::Queue#delete</a>. When a queue is deleted, all of the messages in it are deleted as well.</p>
<pre>queue.delete</pre>
<p>This method takes an optional callback. However, remember that this operation is performed asynchronously. To run a piece of code when the <span class="caps">AMQP</span> broker confirms that a queue has been deleted, use a callback that <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#delete-instance_method"><span class="caps">AMQP</span>::Queue#delete</a> takes:</p>
<pre>queue.delete do |_|
  puts "Deleted #{queue.name}"
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel = AMQP::Channel.new(connection)
  channel.on_error do |ch, channel_close|
    raise "Channel-level exception: #{channel_close.reply_text}"
  end
  exchange = channel.fanout("amq.fanout")

  channel.queue("", :auto_delete =&gt; true, :exclusive =&gt; true) do |queue, declare_ok|
    EventMachine.add_timer(0.5) do
      queue.delete do
        puts "Deleted #{queue.name}"
        connection.close { EventMachine. stop }
      end
    end # EventMachine.add_timer
  end # channel.queue
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/998744">gist</a>)</span></p>
<h2>Objects as message consumers and unit testing consumers in isolation</h2>
<p>Since Ruby is a genuine object-oriented language, it is important to demonstrate how the Ruby amqp gem can be integrated into rich object-oriented code. This part of the guide focuses on queues and the problems/solutions concerning consumer applications (applications that primarily receive and process messages, as opposed to producers that publish them).</p>
<p>An <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Queue#subscribe-instance_method"><span class="caps">AMQP</span>::Queue#subscribe</a> callback does not have to be a block. It can be any Ruby object that responds to the `call` method. A common technique is to combine {http://rubydoc.info/stdlib/core/1.8.7/Object:method Object#method} and {http://rubydoc.info/stdlib/core/1.8.7/Method:to_proc Method#to_proc} and use object methods as message handlers.</p>
<p>An example to demonstrate this technique:</p>
<pre>class Consumer

  #
  # API
  #

  def initialize(channel, queue_name = AMQ::Protocol::EMPTY_STRING)
    @queue_name = queue_name

    @channel    = channel
    # Consumer#handle_channel_exception will handle channel
    # exceptions. Keep in mind that you can only register one error handler,
    # so the last one registered "wins".
    @channel.on_error(&amp;method(:handle_channel_exception))
  end # initialize

  def start
    @queue = @channel.queue(@queue_name, :exclusive =&gt; true)
    # #handle_message method will be handling messages routed to @queue
    @queue.subscribe(&amp;method(:handle_message))
  end # start



  #
  # Implementation
  #

  def handle_message(metadata, payload)
    puts "Received a message: #{payload}, content_type = #{metadata.content_type}"
  end # handle_message(metadata, payload)

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

class Consumer

  #
  # API
  #

  def initialize(channel, queue_name = AMQ::Protocol::EMPTY_STRING)
    @queue_name = queue_name

    @channel    = channel
    @channel.on_error(&amp;method(:handle_channel_exception))
  end # initialize

  def start
    @queue = @channel.queue(@queue_name, :exclusive =&gt; true)
    @queue.subscribe(&amp;method(:handle_message))
  end # start



  #
  # Implementation
  #

  def handle_message(metadata, payload)
    puts "Received a message: #{payload}, content_type = #{metadata.content_type}"
  end # handle_message(metadata, payload)

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end


class Producer

  #
  # API
  #

  def initialize(channel, exchange)
    @channel  = channel
    @exchange = exchange
  end # initialize(channel, exchange)

  def publish(message, options = {})
    @exchange.publish(message, options)
  end # publish(message, options = {})
end


AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel  = AMQP::Channel.new(connection)
  worker   = Consumer.new(channel, "amqpgem.objects.integration")
  worker.start

  producer = Producer.new(channel, channel.default_exchange)
  puts "Publishing..."
  producer.publish("Hello, world", :routing_key =&gt; "amqpgem.objects.integration")

  # stop in 2 seconds
  EventMachine.add_timer(2.0) { connection.close { EventMachine.stop } }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1009425">gist</a>)</span></p>
<p>In this example, <span class="note">Consumer</span> instances have to be instantiated with an <a class="highlight" href="http://rubydoc.info/github/ruby-amqp/amqp/master/AMQP/Channel"><span class="caps">AMQP</span>::Channel</a> instance. If the message handling was done by an aggregated object, it would completely separate the handling logic and would be make it easy to unit test in isolation:</p>
<pre>class Consumer

  #
  # API
  #

  def handle_message(metadata, payload)
    puts "Received a message: #{payload}, content_type = #{metadata.content_type}"
  end # handle_message(metadata, payload)
end


class Worker

  #
  # API
  #


  def initialize(channel, queue_name = AMQ::Protocol::EMPTY_STRING, consumer = Consumer.new)
    @queue_name = queue_name

    @channel    = channel
    @channel.on_error(&amp;method(:handle_channel_exception))

    @consumer   = consumer
  end # initialize

  def start
    @queue = @channel.queue(@queue_name, :exclusive =&gt; true)
    @queue.subscribe(&amp;@consumer.method(:handle_message))
  end # start


  #
  # Implementation
  #

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end</pre>
<p>Full example:</p>
<pre>#!/usr/bin/env ruby
# encoding: utf-8

require "rubygems"
require "amqp"

class Consumer

  #
  # API
  #

  def handle_message(metadata, payload)
    puts "Received a message: #{payload}, content_type = #{metadata.content_type}"
  end # handle_message(metadata, payload)
end


class Worker

  #
  # API
  #


  def initialize(channel, queue_name = AMQ::Protocol::EMPTY_STRING, consumer = Consumer.new)
    @queue_name = queue_name

    @channel    = channel
    @channel.on_error(&amp;method(:handle_channel_exception))

    @consumer   = consumer
  end # initialize

  def start
    @queue = @channel.queue(@queue_name, :exclusive =&gt; true)
    @queue.subscribe(&amp;@consumer.method(:handle_message))
  end # start



  #
  # Implementation
  #

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end


class Producer

  #
  # API
  #

  def initialize(channel, exchange)
    @channel  = channel
    @exchange = exchange
  end # initialize(channel, exchange)

  def publish(message, options = {})
    @exchange.publish(message, options)
  end # publish(message, options = {})


  #
  # Implementation
  #

  def handle_channel_exception(channel, channel_close)
    puts "Oops... a channel-level exception: code = #{channel_close.reply_code}, message = #{channel_close.reply_text}"
  end # handle_channel_exception(channel, channel_close)
end


AMQP.start("amqp://guest:guest@dev.rabbitmq.com") do |connection, open_ok|
  channel  = AMQP::Channel.new(connection)
  worker   = Worker.new(channel, "amqpgem.objects.integration")
  worker.start

  producer = Producer.new(channel, channel.default_exchange)
  puts "Publishing..."
  producer.publish("Hello, world", :routing_key =&gt; "amqpgem.objects.integration")

  # stop in 2 seconds
  EventMachine.add_timer(2.0) { connection.close { EventMachine.stop } }
end
</pre><p><span class="help-block">(if the example above isn&#8217;t displayed, see this <a href="https://gist.github.com/1009447">gist</a>)</span></p>
<p>Note that the <span class="note">Consumer</span> class demonstrated above can be easily tested in isolation without spinning up any <span class="caps">AMQP</span> connections:</p>
<pre>require "ostruct"
require "json"

# RSpec example
describe Consumer do
  describe "when a new message arrives" do
    subject { described_class.new }

    let(:metadata) do
      o = OpenStruct.new

      o.content_type = "application/json"
      o
    end
    let(:payload)  { JSON.encode({ :command =&gt; "reload_config" }) }

    it "does some useful work" do
      # check preconditions here if necessary

      subject.handle_message(metadata, payload)

      # add your code expectations here
    end
  end
end</pre>
<p><span class="caps">TBD</span></p>
<h2>Queue durability vs message durability</h2>
<p>See <a href="/articles/durability/">Durability guide</a></p>
<h2>Error handling and recovery</h2>
<p>See <a href="/articles/error_handling/">Error handling and recovery guide</a></p>
<h2>Vendor-specific extensions related to queues</h2>
<p>See <a href="/articles/broker_specific_extensions/">Vendor-specific Extensions guide</a></p>
<h2>What to read next</h2>
<p>The documentation is organized as several <a href="">documentation guides</a>, covering all kinds of topics. Guides related to this one are:</p>
<ul>
	<li><a href="/articles/working_with_exchanges/">Working With Exchanges</a></li>
	<li><a href="/articles/bindings/">Bindings</a></li>
	<li><a href="/articles/error_handling/">Error handling and recovery</a></li>
</ul>
<p>RabbitMQ implements a number of extensions to <span class="caps">AMQP</span> v0.9.1 functionality that are covered in the <a href="/articles/broker_specific_extensions/">Vendor-specific Extensions guide</a>. At least one extension, per-queue messages time-to-live (<span class="caps">TTL</span>), is related to this guide and can be used with the amqp gem v0.8.0 and later.</p>
<h2>Authors</h2>
This guide was written by
<a href='http://twitter.com/michaelklishin'>
  Michael Klishin
</a>
and edited by
<a href='https://twitter.com/celldee'>
  Chris Duncan
</a>
<h2>Tell us what you think!</h2>
<p>
  Please take a moment to tell us what you think about this guide
  <a href='http://twitter.com/rubyamqp'>
    on Twitter
  </a>
  or the
  <a href='http://groups.google.com/group/ruby-amqp.'>
    Ruby AMQP mailing list
  </a>
</p>
<p>
  Let us know what was unclear or what has not been covered. Maybe you do not like the guide style or grammar or discover spelling mistakes. Reader feedback is key to making the documentation better.
</p>
<p>
  If, for some reason, you cannot use the communication channels mentioned above, you can
  <a href='mailto:michaelklishin@me.com?subject=amqp%20gem%20documentation'>
    contact the author of the guides directly
  </a>
</p>
<div id='disqus_thread'></div>
<script type='text/javascript'>
  //<![CDATA[
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'rubyamqpdocs'; // required: replace example with your forum shortname
    
    var disqus_developer = 0; // set to 1 on local machine for testing comments
    = "var disqus_identifier = 'amqp_queues';"
    = "var disqus_url = 'http://rdoc.info/github/ruby-amqp/amqp/master/file/docs/Queues.textile';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  //]]>
</script></article></section></body></html>